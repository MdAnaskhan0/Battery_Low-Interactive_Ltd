import {
  require_react
} from "./chunk-HDWYUXML.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/.pnpm/@reach+accordion@0.18.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@reach/accordion/dist/reach-accordion.mjs
var React4 = __toESM(require_react(), 1);

// node_modules/.pnpm/@reach+utils@0.18.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@reach/utils/dist/reach-utils.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var React = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_react14 = __toESM(require_react(), 1);
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      return ourHandler(event);
    }
  };
}
function isFunction(value) {
  return !!(value && {}.toString.call(value) == "[object Function]");
}
function assignRef(ref, value) {
  if (ref == null)
    return;
  if (isFunction(ref)) {
    ref(value);
  } else {
    try {
      ref.current = value;
    } catch (error) {
      throw new Error(`Cannot assign value "${value}" to ref "${ref}"`);
    }
  }
}
function useComposedRefs(...refs) {
  return (0, import_react2.useCallback)((node) => {
    for (let ref of refs) {
      assignRef(ref, node);
    }
  }, refs);
}
function createContext2(rootComponentName, defaultContext) {
  let Ctx = React.createContext(defaultContext);
  function Provider(props) {
    let { children, ...context } = props;
    let value = React.useMemo(() => context, Object.values(context));
    return React.createElement(Ctx.Provider, {
      value
    }, children);
  }
  function useContext22(callerComponentName) {
    let context = React.useContext(Ctx);
    if (context) {
      return context;
    }
    if (defaultContext) {
      return defaultContext;
    }
    throw Error(`${callerComponentName} must be rendered inside of a ${rootComponentName} component.`);
  }
  Ctx.displayName = `${rootComponentName}Context`;
  Provider.displayName = `${rootComponentName}Provider`;
  return [Provider, useContext22];
}
function makeId(...args) {
  return args.filter((val) => val != null).join("--");
}
function noop() {
}
function useControlledState({
  controlledValue,
  defaultValue,
  calledFrom = "A component"
}) {
  let wasControlled = controlledValue !== void 0;
  let isControlledRef = (0, import_react5.useRef)(wasControlled);
  if (true) {
    if (!isControlledRef.current && wasControlled) {
      console.warn(`${calledFrom} is changing from controlled to uncontrolled. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`);
    }
    if (isControlledRef.current && !wasControlled) {
      console.warn(`${calledFrom} is changing from uncontrolled to controlled. Components should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`);
    }
  }
  let [valueState, setValue] = (0, import_react5.useState)(isControlledRef.current ? controlledValue : defaultValue);
  let set = (0, import_react5.useCallback)((n) => {
    if (!isControlledRef.current) {
      setValue(n);
    }
  }, []);
  return [isControlledRef.current ? controlledValue : valueState, set];
}
function useForceUpdate() {
  let [, dispatch] = (0, import_react8.useState)(/* @__PURE__ */ Object.create(null));
  return (0, import_react8.useCallback)(() => {
    dispatch(/* @__PURE__ */ Object.create(null));
  }, []);
}
var useIsomorphicLayoutEffect = canUseDOM() ? import_react9.useLayoutEffect : import_react9.useEffect;
function useStatefulRefValue(ref, initialState) {
  let [state, setState] = (0, import_react13.useState)(initialState);
  let callbackRef = (0, import_react13.useCallback)((refValue) => {
    ref.current = refValue;
    setState(refValue);
  }, []);
  return [state, callbackRef];
}

// node_modules/.pnpm/@reach+descendants@0.18.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@reach/descendants/dist/reach-descendants.mjs
var React2 = __toESM(require_react(), 1);
function createDescendantContext(name, initialValue = {}) {
  const descendants = [];
  let ctx = React2.createContext({
    descendants,
    registerDescendant: () => noop,
    ...initialValue
  });
  ctx.displayName = name;
  return ctx;
}
function useDescendant(descendant, context, indexProp) {
  let forceUpdate = useForceUpdate();
  let { registerDescendant, descendants } = React2.useContext(context);
  let index = indexProp ?? descendants.findIndex((item) => item.element === descendant.element);
  useIsomorphicLayoutEffect(() => {
    if (!descendant.element)
      forceUpdate();
    return registerDescendant({ ...descendant, index });
  }, [
    descendant,
    forceUpdate,
    index,
    registerDescendant,
    ...Object.values(descendant)
  ]);
  return index;
}
function useDescendantsInit() {
  return React2.useState([]);
}
function DescendantProvider({
  context: Ctx,
  children,
  items,
  set
}) {
  let registerDescendant = React2.useCallback(({
    element,
    index: explicitIndex,
    ...rest
  }) => {
    if (!element)
      return noop;
    set((items2) => {
      if (explicitIndex != null && explicitIndex !== -1) {
        return insertAt(items2, { element, index: explicitIndex, ...rest }, explicitIndex);
      }
      if (items2.length === 0) {
        return [{ ...rest, element, index: 0 }];
      }
      if (true) {
        if (items2.find((item) => item.element === element)) {
          console.warn("[reach-ui]: `useDescendant` was called with an element that was already registered.\n\nIf you are using the `@reach/descendants` package directly, make sure to only register descendants once. Registering a descendant more than once will lead to bugs in your app.\n\nIf you are using another `reach-ui` package, this is probably our bug!\n\nTo report a bug, open a new issue:\n\n  https://github.com/reach/reach-ui/issues/new?assignees=&labels=&template=Bug_report.md\n\nIMPORTANT: this check will only run in the development build, so if you see this warning please be aware that your app may crash when deployed.");
          return updateIndices(items2);
        }
      }
      let index = findDOMIndex(items2, element);
      let newItems;
      if (index === -1) {
        newItems = [
          ...items2,
          { ...rest, element, index: items2.length }
        ];
      } else {
        newItems = insertAt(items2, { ...rest, element, index }, index);
      }
      return newItems;
    });
    return () => {
      if (!element)
        return;
      set((items2) => items2.filter((item) => element !== item.element));
    };
  }, []);
  return React2.createElement(Ctx.Provider, {
    value: React2.useMemo(() => {
      return {
        descendants: items,
        registerDescendant
      };
    }, [items, registerDescendant])
  }, children);
}
function useDescendantKeyDown(context, options) {
  let { descendants } = React2.useContext(context);
  let {
    callback,
    currentIndex,
    filter,
    key = "index",
    orientation = "vertical",
    rotate = true,
    rtl = false
  } = options;
  return function handleKeyDown(event) {
    if (![
      "ArrowDown",
      "ArrowUp",
      "ArrowLeft",
      "ArrowRight",
      "PageUp",
      "PageDown",
      "Home",
      "End"
    ].includes(event.key)) {
      return;
    }
    let index = currentIndex ?? -1;
    let selectableDescendants = filter ? descendants.filter(filter) : descendants;
    if (!selectableDescendants.length) {
      return;
    }
    let selectableIndex = selectableDescendants.findIndex((descendant) => descendant.index === currentIndex);
    function getNextOption() {
      let atBottom = index === getLastOption().index;
      return atBottom ? rotate ? getFirstOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex + 1) % selectableDescendants.length];
    }
    function getPreviousOption() {
      let atTop = index === getFirstOption().index;
      return atTop ? rotate ? getLastOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex - 1 + selectableDescendants.length) % selectableDescendants.length];
    }
    function getFirstOption() {
      return selectableDescendants[0];
    }
    function getLastOption() {
      return selectableDescendants[selectableDescendants.length - 1];
    }
    switch (event.key) {
      case "ArrowDown":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          let next = getNextOption();
          callback(key === "option" ? next : next[key]);
        }
        break;
      case "ArrowUp":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          let prev = getPreviousOption();
          callback(key === "option" ? prev : prev[key]);
        }
        break;
      case "ArrowLeft":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          let nextOrPrev = (rtl ? getNextOption : getPreviousOption)();
          callback(key === "option" ? nextOrPrev : nextOrPrev[key]);
        }
        break;
      case "ArrowRight":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          let prevOrNext = (rtl ? getPreviousOption : getNextOption)();
          callback(key === "option" ? prevOrNext : prevOrNext[key]);
        }
        break;
      case "PageUp":
        event.preventDefault();
        let prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();
        callback(key === "option" ? prevOrFirst : prevOrFirst[key]);
        break;
      case "Home":
        event.preventDefault();
        let first = getFirstOption();
        callback(key === "option" ? first : first[key]);
        break;
      case "PageDown":
        event.preventDefault();
        let nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();
        callback(key === "option" ? nextOrLast : nextOrLast[key]);
        break;
      case "End":
        event.preventDefault();
        let last = getLastOption();
        callback(key === "option" ? last : last[key]);
        break;
    }
  };
}
function isElementPreceding(a, b) {
  return Boolean(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function findDOMIndex(items, element) {
  if (!element)
    return -1;
  if (!items.length)
    return -1;
  let length = items.length;
  while (length--) {
    let currentElement = items[length].element;
    if (!currentElement)
      continue;
    if (isElementPreceding(currentElement, element)) {
      return length + 1;
    }
  }
  return -1;
}
function insertAt(array, item, index) {
  if (index == null || !(index in array)) {
    return [...array, item];
  }
  return [...array.slice(0, index), item, ...array.slice(index)];
}
function updateIndices(items) {
  return items.sort((a, b) => !a.element || !b.element ? 0 : isElementPreceding(a.element, b.element) ? -1 : 1).map((item, index) => ({ ...item, index }));
}

// node_modules/.pnpm/@reach+auto-id@0.18.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@reach/auto-id/dist/reach-auto-id.mjs
var React3 = __toESM(require_react(), 1);
var serverHandoffComplete = false;
var id = 0;
function genId() {
  return ++id;
}
var maybeReactUseId = React3["useId".toString()];
function useId(providedId) {
  if (maybeReactUseId !== void 0) {
    let generatedId = maybeReactUseId();
    return providedId ?? generatedId;
  }
  let initialId = providedId ?? (serverHandoffComplete ? genId() : null);
  let [id2, setId] = React3.useState(initialId);
  useIsomorphicLayoutEffect(() => {
    if (id2 === null) {
      setId(genId());
    }
  }, []);
  React3.useEffect(() => {
    if (serverHandoffComplete === false) {
      serverHandoffComplete = true;
    }
  }, []);
  return providedId ?? id2 ?? void 0;
}

// node_modules/.pnpm/@reach+accordion@0.18.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@reach/accordion/dist/reach-accordion.mjs
var AccordionDescendantContext = createDescendantContext("AccordionDescendantContext");
var [AccordionProvider, useAccordionCtx] = createContext2("Accordion");
var [AccordionItemProvider, useAccordionItemCtx] = createContext2("AccordionItem");
var AccordionStates = ((AccordionStates2) => {
  AccordionStates2["Open"] = "OPEN";
  AccordionStates2["Collapsed"] = "COLLAPSED";
  return AccordionStates2;
})(AccordionStates || {});
var Accordion = React4.forwardRef(function Accordion2({
  as: Comp = "div",
  children,
  defaultIndex,
  index: controlledIndex,
  onChange,
  readOnly = false,
  collapsible = false,
  multiple = false,
  ...props
}, forwardedRef) {
  let [openPanels, setOpenPanels] = useControlledState({
    controlledValue: controlledIndex,
    defaultValue: () => {
      if (defaultIndex != null) {
        if (multiple) {
          return Array.isArray(defaultIndex) ? defaultIndex : [defaultIndex];
        } else {
          return Array.isArray(defaultIndex) ? defaultIndex[0] ?? 0 : defaultIndex;
        }
      }
      if (collapsible) {
        return multiple ? [] : -1;
      }
      return multiple ? [0] : 0;
    },
    calledFrom: "Tabs"
  });
  let [descendants, setDescendants] = useDescendantsInit();
  let id2 = useId(props.id);
  let onSelectPanel = React4.useCallback((index) => {
    onChange && onChange(index);
    setOpenPanels((prevOpenPanels) => {
      index = index;
      if (multiple) {
        prevOpenPanels = prevOpenPanels;
        if (prevOpenPanels.includes(index)) {
          if (prevOpenPanels.length > 1 || collapsible) {
            return prevOpenPanels.filter((i) => i !== index);
          }
        } else {
          return [...prevOpenPanels, index].sort();
        }
      } else {
        prevOpenPanels = prevOpenPanels;
        return prevOpenPanels === index && collapsible ? -1 : index;
      }
      return prevOpenPanels;
    });
  }, [collapsible, multiple, onChange, setOpenPanels]);
  return React4.createElement(DescendantProvider, {
    context: AccordionDescendantContext,
    items: descendants,
    set: setDescendants
  }, React4.createElement(AccordionProvider, {
    accordionId: id2,
    openPanels,
    onSelectPanel: readOnly ? noop : onSelectPanel,
    readOnly
  }, React4.createElement(Comp, {
    ...props,
    ref: forwardedRef,
    "data-reach-accordion": ""
  }, children)));
});
Accordion.displayName = "Accordion";
var AccordionItem = React4.forwardRef(function AccordionItem2({ as: Comp = "div", children, disabled = false, index: indexProp, ...props }, forwardedRef) {
  let { accordionId, openPanels, readOnly } = useAccordionCtx("AccordionItem");
  let buttonRef = React4.useRef(null);
  let [element, handleButtonRefSet] = useStatefulRefValue(buttonRef, null);
  let descendant = React4.useMemo(() => {
    return {
      element,
      disabled
    };
  }, [disabled, element]);
  let index = useDescendant(descendant, AccordionDescendantContext, indexProp);
  let itemId = makeId(accordionId, index);
  let panelId = makeId("panel", itemId);
  let buttonId = makeId("button", itemId);
  let state = (Array.isArray(openPanels) ? openPanels.includes(index) && "OPEN" : openPanels === index && "OPEN") || "COLLAPSED";
  let context = {
    buttonId,
    buttonRef,
    disabled,
    handleButtonRefSet,
    index,
    itemId,
    panelId,
    state
  };
  return React4.createElement(AccordionItemProvider, {
    ...context
  }, React4.createElement(Comp, {
    ...props,
    ref: forwardedRef,
    "data-reach-accordion-item": "",
    "data-state": getDataState(state),
    "data-disabled": disabled ? "" : void 0,
    "data-read-only": readOnly ? "" : void 0
  }, children));
});
AccordionItem.displayName = "AccordionItem";
var AccordionButton = React4.forwardRef(function AccordionButton2({
  as: Comp = "button",
  children,
  onClick,
  onKeyDown,
  onMouseDown,
  onPointerDown,
  tabIndex,
  ...props
}, forwardedRef) {
  let { onSelectPanel } = useAccordionCtx("AccordionButton");
  let {
    disabled,
    buttonId,
    buttonRef: ownRef,
    handleButtonRefSet,
    index,
    panelId,
    state
  } = useAccordionItemCtx("AccordionButton");
  let ref = useComposedRefs(forwardedRef, handleButtonRefSet);
  function handleClick(event) {
    event.preventDefault();
    if (disabled) {
      return;
    }
    ownRef.current.focus();
    onSelectPanel(index);
  }
  let handleKeyDown = useDescendantKeyDown(AccordionDescendantContext, {
    currentIndex: index,
    orientation: "vertical",
    key: "element",
    rotate: true,
    callback(element) {
      element == null ? void 0 : element.focus();
    },
    filter: (button) => !button.disabled
  });
  return React4.createElement(Comp, {
    "aria-controls": panelId,
    "aria-expanded": state === "OPEN",
    tabIndex: disabled ? -1 : tabIndex,
    ...props,
    ref,
    "data-reach-accordion-button": "",
    "data-state": getDataState(state),
    disabled: disabled || void 0,
    id: buttonId,
    onClick: composeEventHandlers(onClick, handleClick),
    onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown)
  }, children);
});
AccordionButton.displayName = "AccordionButton";
var AccordionPanel = React4.forwardRef(function AccordionPanel2({ as: Comp = "div", children, ...props }, forwardedRef) {
  let { disabled, panelId, buttonId, state } = useAccordionItemCtx("AccordionPanel");
  return React4.createElement(Comp, {
    hidden: state !== "OPEN",
    role: "region",
    "aria-labelledby": buttonId,
    ...props,
    ref: forwardedRef,
    "data-reach-accordion-panel": "",
    "data-disabled": disabled || void 0,
    "data-state": getDataState(state),
    id: panelId
  }, children);
});
AccordionPanel.displayName = "AccordionPanel";
function useAccordionContext() {
  let { openPanels, accordionId } = useAccordionCtx("useAccordionContext");
  return React4.useMemo(() => {
    let panels = [];
    return {
      id: accordionId,
      openPanels: panels.concat(openPanels).filter((i) => i >= 0)
    };
  }, [accordionId, openPanels]);
}
function useAccordionItemContext() {
  let { index, state } = useAccordionItemCtx("useAccordionItemContext");
  return React4.useMemo(() => ({
    index,
    isExpanded: state === "OPEN"
    /* Open */
  }), [index, state]);
}
function getDataState(state) {
  return state === "OPEN" ? "open" : "collapsed";
}
export {
  Accordion,
  AccordionButton,
  AccordionItem,
  AccordionPanel,
  AccordionStates,
  useAccordionContext,
  useAccordionItemContext
};
/*! Bundled license information:

@reach/utils/dist/reach-utils.mjs:
  (**
    * @reach/utils v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/descendants/dist/reach-descendants.mjs:
  (**
    * @reach/descendants v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/auto-id/dist/reach-auto-id.mjs:
  (**
    * @reach/auto-id v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)

@reach/accordion/dist/reach-accordion.mjs:
  (**
    * @reach/accordion v0.18.0
    *
    * Copyright (c) 2018-2022, React Training LLC
    *
    * This source code is licensed under the MIT license found in the
    * LICENSE.md file in the root directory of this source tree.
    *
    * @license MIT
    *)
*/
//# sourceMappingURL=@reach_accordion.js.map
